---
title: "Launching OTP"
author: "Jonathon Sun"
date: "1/25/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

if(!require('pacman')) {install.packages('pacman')}
pacman::p_load(opentripplanner, tidytransit, tidyverse, sf, tigris, ggmap, tidycensus)

register_google(key = "AIzaSyDIDS0OgrYmmrJO221DhqIaEnMq9tQrMr0") 
options(scipen = 999)
options(scipen =  "sf")

source("https://raw.githubusercontent.com/urbanSpatial/Public-Policy-Analytics-Landing/master/functions.r")
```

# Tidytransit

I'm using the Tidytransit package to make sure that the gtfs files work. Currently they work, we will see if they continue to work. Test

```{r eval=FALSE, include=FALSE}
GTFS_path <- c("OTP\\graphs\\default\\google_bus.zip")

GTFS <- read_gtfs(GTFS_path)

validation_result <- attr(GTFS, "validation_result")
head(validation_result)

GTFS_path <- c("OTP\\graphs\\default\\google_rail.zip")

GTFS <- read_gtfs(GTFS_path)

validation_result <- attr(GTFS, "validation_result")
head(validation_result)

#This line below attempts to pull the data  feed data from the github directly it doesn't work. 
#head(feedlist)
#glimpse(feedlist)
#Philly <- feedlist %>%
#  filter(loc_n == "Philadelphia") %>%
#  pull(url_d) %>%
#  read_gtfs()
```


# Open Trip Planner

I moved this to a separate RMD because a lot of this is just making separace CSV's that I can save and import to my full file. 


```{r message=FALSE, warning=FALSE, include=FALSE}
path_data <- file.path("OTP")
dir.create(path_data) 

path_otp <- otp_dl_jar()

#log1 <- otp_build_graph(otp = path_otp , dir = path_data, memory = 10240) 


#By default, R will assign OTP 2GB of memory to build the graph. For larger areas, you may need more memory. You can use the memory argument to set the memory allocation in MB. For example, to allocate 10GB, you would use:


#log1 <- otp_build_graph(otp = path_otp, dir = path_data, memory = 10240) 


#Note that you cannot allocate more memory than you have RAM, and if you use 32 Bit Java you cannot allocate more than 3GB. It is possible to run OTP in just 1GB of memory for very small areas (including the demo dataset).

# Launch OTP and load the graph

#The next step is to start up your OTP server, running the router called ‘default’. OTP will load the graph you created into memory, and you will then be able to plan multi-modal routes using the web interface. Run the following command:

log2 <- otp_setup(otp = path_otp, dir = path_data)

otpcon <- otp_connect(hostname =  "localhost",
                      router = "default",
                      port = 8080)

```

## Simple Features

Whatver you get out of the OTP instance, you need to flip around when you put it into the OTP planner. I don't know which one is longitude and latitude. 
```{r message=FALSE, warning=FALSE, include=FALSE}
Philadelphia <- tigris::counties(state = "PA") %>%
                  filter(NAMELSAD == "Philadelphia County")

Vietlead <- c(-75.1536303,39.9128769)
toPlace <- c(-75.15661,39.98113)


route <- otp_plan(otpcon,
                  fromPlace = c(-75.17670, 39.96870),
                  toPlace = Vietlead,
                  mode = c("WALK","TRANSIT"))
ggplot() +
  geom_sf(data = route) +
  geom_sf(data = Philadelphia,
          fill = "transparent")
```

```{r echo=TRUE, message=FALSE, warning=FALSE}
ggplot() +
  geom_sf(data = routes, aes(color = duration)) +
  geom_sf(data = Philadelphia,
          fill = "transparent") +
  labs(title = "Universities to Vietlead") +
  mapTheme()
  

```
## Avanced Features

Showing multiple routes from one place to multiple locations. 

Basically, the batched routes only work for different kinds of transporatation combinations. I thought it was a syntax error but for some modes of transportation things work and other times they don't 

```{r message=FALSE, warning=FALSE, include=FALSE}
Locations <- c("Vietlead Philadelphia","Asian Americans United Philadelphia","Chinatown Philadelphia","Mayflower Bakery Philadelphia","Bread Top House Philadelphia")

locations_LatLon <- geocode(location = Locations)
locations_Shp <- locations_LatLon %>% 
  rename(Longitude = lon,
         Latitude = lat) %>%
  st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326, agr = "constant") %>%
  st_transform(st_crs(Universities)) %>%
  cbind(Locations)

routes <- otp_plan(otpcon = otpcon,
                   fromPlace = Universities,
                   toPlace = Vietlead,
                   mode = c("WALK","TRANSIT"))

fromPlace <- as.numeric(locations_LatLon[1,1:2])

routes <- otp_plan(otpcon = otpcon,
                   fromPlace = fromPlace,
                   toPlace = Universities,
                   mode = c("WALK","TRANSIT"),
                   date_time = as.POSIXct(strptime("2022-01-25 12:00","%Y-%m-%d %H:%M")))


# Philadelphia Centroids to Universities -----------------------------------------------

fromPlace <- fromPlace <- as.numeric(locations_LatLon[1,1:2])

Locations_routes <- otp_plan(otpcon = otpcon,
                   fromPlace = fromPlace,
                   toPlace = Universities,
                   mode = c("WALK","TRANSIT"),
                   date_time = as.POSIXct(strptime("2022-01-24 12:00","%Y-%m-%d %H:%M"))) %>%
                    mutate(Start_Location = Locations[1]) 

for(i in 2:nrow(locations_LatLon)) {
  tryCatch({
    
fromPlace <- fromPlace <- as.numeric(locations_LatLon[i,1:2])

    A <- otp_plan(otpcon = otpcon,
                   fromPlace = fromPlace,
                   toPlace = Universities,
                   mode = c("WALK","TRANSIT"),
                   date_time = as.POSIXct(strptime("2022-01-24 12:00","%Y-%m-%d %H:%M"))) %>%
        mutate(Start_Location = Locations[i]) 

   Locations_routes <- rbind(Locations_routes,A)
   
    
  }, error=function(e){cat("ERROR: ", conditionMessage(e), "\n")})

}

```


# Appendix, don't run this code ------------------------------------


## Batched 

This chunk can run. It just runs for a while. It needs to be refined a bit more. 

```{r eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
Locations <- rbind(Universities%>%
        select(NAME),
      locations_Shp %>%
        rename(NAME = Locations),
      Philadelphia_Centroids %>%
        select(NAME))

Locations <- Locations %>%
              mutate(id = row_number())

toPlace   = Locations[rep(seq(1, nrow(Locations)), times = nrow(Locations)),]
fromPlace = Locations[rep(seq(1, nrow(Locations)), each  = nrow(Locations)),]

routes <- otp_plan(otpcon = otpcon,
                   fromPlace = fromPlace,
                   toPlace = toPlace,
                   fromID = fromPlace$NAME,
                   toID = toPlace$NAME,
                   ncores = 6)
```

Not batched, looped

```{r This chunk needs fixing, eval=FALSE, include=FALSE}
# Philadelphia Centroids to Universities -----------------------------------------------

Reconnect <- seq(from = 8, to = nrow(Philadelphia_Centroids), by = 20)

fromPlace <- Philadelphia_Centroids %>%
                          select() %>%
                          slice(1) 

Census_routes <- otp_plan(otpcon = otpcon,
                   fromPlace = fromPlace,
                   toPlace = Universities,
                   mode = c("WALK","TRANSIT"),
                   date_time = as.POSIXct(strptime("2022-01-24 12:00","%Y-%m-%d %H:%M")))  
                  

for(i in 2:nrow(Philadelphia_Centroids)) {
  if(i %in% Reconnect == TRUE) {
    
    log2 <- otp_setup(otp = path_otp, dir = path_data)

    otpcon <- otp_connect(hostname =  "localhost",
                          router = "default",
                          port = 8080)
    
      tryCatch({
    
    fromPlace <- Philadelphia_Centroids %>%
                          select() %>%
                          slice(i)

    A <- otp_plan(otpcon = otpcon,
                   fromPlace = fromPlace,
                   toPlace = Universities,
                   mode = c("WALK","TRANSIT"),
                   date_time = as.POSIXct(strptime("2022-01-24 12:00","%Y-%m-%d %H:%M")))

   Census_routes <- rbind(Census_routes,A)
   
    
  }, error=function(e){cat("ERROR: ", conditionMessage(e), "\n")})
  }
  else if (i %in% Reconnect == FALSE) {
    tryCatch({
    
    fromPlace <- Philadelphia_Centroids %>%
                          select() %>%
                          slice(i)

    A <- otp_plan(otpcon = otpcon,
                   fromPlace = fromPlace,
                   toPlace = Universities,
                   mode = c("WALK","TRANSIT"),
                   date_time = as.POSIXct(strptime("2022-01-24 12:00","%Y-%m-%d %H:%M")))

   Census_routes <- rbind(Census_routes,A)
   
    
  }, error=function(e){cat("ERROR: ", conditionMessage(e), "\n")})
    
    
  }
}


ggplot() +
  geom_sf(data = Philadelphia) +
  geom_sf(data = routes) +
  geom_sf(data = Philadelphia_Centroids %>%
                          select() %>%
                          slice(i))
```

## Isochrones

```{r}
Values <- c(15,30,45,60,75,90)


Isochrone <- otp_isochrone(otpcon = otpcon,
                           fromPlace = Vietlead,
                           mode = c("WALK","TRANSIT"),
                           maxWalkDistance = 20,
                           date_time = as.POSIXct(strptime("2022-01-20 17:00","%Y-%m-%d %H:%M")),
                           cutoffSec = Values)

library(tmap)
tmap_mode("view")


map <- tm_shape(Isochrone) +  # Build the map
  tm_borders()
map           
```